---           
layout: post
title: Truecrypt mit Keyfiles und pam_exec automatisch mounten
date: 2014-04-10 21:23:07 UTC
updated: 2014-04-10 21:23:07 UTC
comments: true
categories: security privacy
---

<p>Nachdem ich in im letzten <a href="/linux/2014/04/06/hibernate-and-resume-with-dm-crypt.html">Artikel</a> kurz beschrieben habe, warum ich mich f&uuml;r <a href="http://ww.truecrypt.org">truecrypt</a> entschieden habe, m&ouml;chte ich nun kurz zeigen, wie man mit Hilfe von <a href="http://www.linux-pam.org/Linux-PAM-html/sag-pam_exec.html">pam_exec</a> verschl&uuml;sselte Datentr&auml;ger mit <a href="http://www.truecrypt.org/docs/keyfiles">Schl&uuml;sseldateien</a> einbindet.</p>

<p>Mein System is effektiv hat nur einen menschlichen Nutzer, daher wird im Folgenden nicht nach unterschiedlichen Nutzern unterschieden.</p>

<h2>Ziel</h2>

<p>Eine Zeile pro Datenträger der mit einer Schlüsseldatei mit Hilfe von <tt>pam_exec</tt> gemountet wird.</p>

{% highlight bash %}
session    optional        pam_exec.so ...
{% endhighlight %}

<p>Die Integration mit <tt>pam_mount</tt> habe ich nicht in Betracht gezogen, weil mir keine Möglichkeit zum sicheren Identifizieren der Festplatten (siehe unten) ersichtlich war.</p>

<h2>Vorgehensweise</h2>

<ol>
  <li><a href="#enc">Verschlüsseln der Datenträger</a></li>
  <li><a href="#id">Identifizieren der Datenträger</a></li>
  <li><a href="#pam">Einbindung mit pam_exec</a></li>
  <li><a href="#debug">Tipps zum Debugging</a></li>
</ol>

<hr/>

<h2 id="enc">1. Verschlüsseln des Datenträgers</h2>

<p>Hier verweise ich auf Truecrypt im <a href="https://wiki.archlinux.de/title/TrueCrypt">ArchLinux Wiki</a> oder man nimmt einfach die GUI.</p>

<h2 id="id">2. Identifizieren der Datenträger</h2>

<p>Mittels <code>blkid</code> erscheinen die verschlüsselten Datenträger leider nicht auf. Also muss man sie anders ermitteln. Da ich eine 2TB und eine 3TB Festplatte habe, musste ich <code><a href="http://wiki.ubuntuusers.de/gdisk">gdisk</a></code> (f<b>disk</b> für <b>G</b>PT) verwenden.</p>

<p>Weil ich gemischte Partitionstabellen habe (nach alter und neuer Bauart), sind die Identifizierungsnummern der Festplatten mit alter Partitionstablle mit <code>gdisk</code> bei aufeinanderfolgenden Aufrufen nicht identisch:

{% highlight bash %}
# erster Aufruf
gdisk -l /dev/sdc | grep "^Disk identifier" | cut -d\   -f4 
1DA8415E-997C-4264-8037-C159FEF26AAD

# zweiter Aufruf
gdisk -l /dev/sdc | grep "^Disk identifier" | cut -d\   -f4 
A7A3912B-DE0F-4B0A-A6E3-A06DF8E4EDE7

# dritter Aufruf
gdisk -l /dev/sdc | grep "^Disk identifier" | cut -d\   -f4 
D16AB7A6-B045-4398-84C2-1236EF6111E1

...
{% endhighlight %}
</p>

<p>Da ich nicht schon wieder die ganzen Daten kopieren wollte, musste ein Workaround her. Ich habe mich dann an die Seriennummern von Festplatten erinnert und mit <code>hdparm</code> ermitteln können:

{% highlight bash %}
hdparm -i /dev/sdc | grep SerialNo | cut -d= -f4
6XW139KA
{% endhighlight %}

<h2 id="pam">3. Einbindung mit pam_exec</h2>

<p>Nun noch die Integration mit <tt>PAM</tt>.</p>

<p>Hierzu bitte ins Verzeichnis <tt>/etc/pam.d</tt> wechseln und die Datei <tt>login</tt> öffnen. Dort sehen wir, dass auf <tt>common-session</tt> verwiesen wird:

{% highlight bash %}
...
# Standard Un*x account and session
@include common-account
@include common-session
@include common-password
...
{% endhighlight %}

</p>

<p>
Dort stand bei mir bisher:

{% highlight bash %}
...
session required        pam_unix.so
session optional        pam_winbind.so
session optional        pam_mount.so    debug
session optional        pam_systemd.so
session optional        pam_ecryptfs.so unwrap
session optional        pam_ck_connector.so nox11
{% endhighlight %}

<code class="warning">Bitte <tt>pam_exec</tt> nur als <b>optional</b> konfigurieren. Denn sollte etwas beim Anmelden schief gehen, würde man sich eventuell aussperren.</code>

<p>Das sieht dann so aus:</p>

{% highlight bash %}
...

session optional        pam_ecryptfs.so unwrap
session optional        pam_ck_connector.so nox11

session optional        pam_exec.so     <parameter>
{% endhighlight %}

Aus Gründen der Darstellung liste ich <tt>&lt;parameter&gt;<tt> hier separat auf:

<p style="line-height: 3rem">
	<code>debug</code> allg. Flag für das Logging<br/>
	<code>log=/var/log/pam_exec.log</code> Skriptausgaben in diese Datei <br/>
	<code>mountTruecryptByGUID.sh</code> Skript zum Mounten (siehe unten) <br/>
	<code>backup_disk.key</code> Schlüsseldatei <br/>
	<code>Z1F1LF69</code> Seriennummer der Festplatte <br/>
	<code>1</code> Partitionsnummer z.B <tt>/dev/sda<b>1</b></tt> <br/>
	<code>/backup</code> Mountpoint <br/>
 </p>
 
 Alle Pfade sollten natürlich absolut sein ;).
</p> 

<p>
Das Skript dazu sieht dann wie folgt aus:
{% highlight bash %}
#!/bin/bash

set -e
#set -x

if [ $# -ne 4 ]
then
  echo "Usage: `basename $0` <keyfile> <serialNo> <partition-nr> <mountpoint>"
  echo 
  echo "serialNo can be retrieved from 'hdparm -i /dev/sda' "
  exit 1
fi

keyfile=$1
serialNo=$2
partition=$3
mountpoint=$4

if [ -z "$PAM_TYPE" ]; then
        echo "INFO running outside of pam"
else
        if [ "$PAM_TYPE" == "close_session" ]; then
                echo "INFO skipping mounting (closing session)"
                exit 0
        fi
fi

function _mount(){
        local keyfile=$1
        local device=$2
        local mountpoint=$3

        /usr/bin/truecrypt --text --protect-hidden=no --non-interactive --keyfiles=$keyfile $device $mountpoint
}

for device in $(fdisk -l 2>/dev/null| grep ^Disk | sed -e 's#Disk\ \(.*\?\):.*#\1#g'| xargs );
do
        serial=$(hdparm -i $device 2>/dev/null| grep SerialNo | cut -d= -f4)

        if [ "$serial" == "$serialNo" ];
        then
                echo "$device $serial"

                # skip if already mounted
                truecrypt --text -l | cut -d\  -f2 | grep $device$partition > /dev/null || \
                        _mount $keyfile $device$partition $mountpoint
        fi
done
{% endhighlight %}
</p>

<p>
Geschafft! 
</p>

<h2 id="debug">4. Tipps zum Debugging</h2>

<ul style="line-height: 3rem;">
	<li>das <code>debug</code> Flag in der Konfiguration</li>
	<li>mit dem Schalter <code>set -x</code> im Skript kann man beim Anmelden in jeder Konsole mit <code>sudo su &lt;Nutzername&gt;</code> das Skript testen</li>
</ul>
